from heapq import heappop, heappushimport operatordef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    # get starting boxes    startBox = getBox(source_point, mesh)    endBox = getBox(destination_point, mesh)    lastBox = None    emptyBox = (0,0,0,0)    # if the start or end isn't in a box on the mesh then exit early    if startBox == None or endBox == None: return path, boxes.keys()    # Start by visiting both the end and start    boxes[startBox] = (0, startBox, startBox, emptyBox)    boxes[endBox] = (0, endBox, emptyBox, endBox)    # And then cache the value    # These should all be of the form    '''    Cost, Box, Previous, Next (Successor)    Cost: int    Box: (x1, x2, y1, y2) where x1<x2 and y1<y2 (aka rectangle)    Previous, Next: Reference to the previous or next box associated    '''    heap = [(0, startBox, startBox, emptyBox),            (0, endBox, emptyBox, endBox)]    # repeat until the heap is empty    while len(heap)>0:        cost, box, prev, succ = heappop(heap)        if box in boxes and boxes[box][3] != succ:            lastBox = box            boxes[box] = (cost, box,                          tuple(map(operator.add, prev, boxes[box][2])),                          tuple(map(operator.add, succ, boxes[box][3])))            break        if prev == emptyBox:            #do search from back            neighs = FindNeighbors(box, mesh, source_point)            for neigh in map(lambda n: (n[1]+cost, n[0], emptyBox, box),                             filter(lambda n: not(n[0] in boxes and                                              boxes[n[0]][2]==emptyBox),                                    neighs)):                heappush(heap, neigh)                if neigh[1] in boxes: continue                boxes[neigh[1]] = neigh            pass        elif succ == emptyBox:            #do search from front            neighs = FindNeighbors(box, mesh, destination_point)            for neigh in map(lambda n: (n[1]+cost, n[0], box, emptyBox),                             filter(lambda n: not(n[0] in boxes and                                              boxes[n[0]][3]==emptyBox),                                    neighs)):                heappush(heap, neigh)                if neigh[1] in boxes: continue                boxes[neigh[1]] = neigh        else:            # Found solution            pass    if lastBox == None:        print("no path")        return path, boxes.keys()    print(boxes[lastBox])    prevList = []    curr = lastBox    while curr != boxes[curr][2]:        path.insert(0, ((BoxCenter(boxes[curr][2]),                         BoxCenter(curr))))        curr = boxes[curr][2]    print(path)    curr = lastBox    while curr != boxes[curr][3]:        path.append((BoxCenter(curr),                     BoxCenter(boxes[curr][3])))        curr = boxes[curr][3]        return path, boxes.keys()def FindNeighbors(box, mesh, destination):    """ returns neighbors as [(point, cost, entry),...]"""    return ([(b, Distance(BoxCenter(b),BoxCenter(box))              + Distance(BoxCenter(b), destination)) for b in mesh['adj'][box]])    return []# Finds the box that the point is indef getBox(point, mesh):    box = list(filter(        lambda box: box[0]<point[0] and box[1]>point[0] and                    box[2]<point[1] and box[3]>point[1],        mesh['boxes']))    if(len(box)!= 1): return None    return box[0]def BoxCenter(box):    return ((box[0]+box[1])/2,(box[2]+box[3])/2)def Distance(p1, p2):    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2